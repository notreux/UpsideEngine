// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

declare interface table { [key: string | number | symbol]: any; }
declare interface Dictionary<k,v> extends Record<any, any> {}
declare interface ChromaticAberrationConnection {}

declare interface Event {
	Functions: {},
	Threads: {},
}

export type ShadingParams = {
    x: number;
    y: number;
    red: number;
    green: number;
    blue: number;
    opacity: number;
    rotate: (centre: Vector2 | Vector3, position: Vector2 | Vector3, degrees: number) => [number, number];
    texture: (imageLabel: ImageLabel, position: Vector2 | Vector3) => void;
};

declare interface RequestContent {
	ClassName: string,
	Id: string,
	Name: string,
	Instance: {},
	ObjectProperties: {},
}

declare interface Raycast2dResult { 
    Object: PhysicalObject;
    Position: UDim2;
    Distance: Vector2;
    Normal: UDim2 
}

declare interface Raycast2dParams { 
    Filterinterface: string;
    From: Vector2;
    List: Array<BaseObject>;
    To: any 
}

declare interface BaseClass {
    Id: string,
    ClassName: string,
	Name: string,
    SetName(name: string): any;
    IsA(self: BaseClass,className: string): boolean;
    new(...any): BaseClass;
    Clone(...any): BaseClass;
    Extend(self: BaseClass,className: string,classStructure: table): BaseClass;
    Destroy(): any;
}

declare interface UpsideEngineInput {
	Action: string,
	Position: Vector2,
	KeyCode: Enum.KeyCode,
}/**
This class is the base class of the majority of classes
	
*/ 
export declare interface BaseObject extends EventEmitter {
/**
The object instance
  
*/
Instance: Instance;
/**
The object scene ID
  
*/
Scene: string;
/**
This table stores all the tags of the object

*/
Tags: { };
/**
Sets the object scene
	
*/
SetScene(scene: Scene): null;
/**
Adds a tag to the object
	
*/
AddTag(tag: string): null;
/**
Checks if the object contain the specified tag
	
*/
HasTag(tag: string): boolean;
/**
Removes a tag from the object
	
*/
RemoveTag(tag: string): null;
}
 



/**
This class is included on every scene, it's used to move you around the scene
	
*/ 
export declare interface Camera extends EventEmitter {
/**
This property serves to move as many pixels as you want the camera to adjust it to a desired position
  
*/
OffsetPosition: UDim2;
/**
This property is used to move the camera internally
  
*/
LocalPosition: Vector2;
/**
This property marks the limits to move the camera, for example, if you set `Vector2.new(0.5, 0.5)` the camera will move only when it reaches the limit
  
*/
Limits: Vector2;
/**
This property defines if the camera is going to follow the defined subject
  
*/
FollowSubject: boolean;
/**
This is the Scene Id of the camera
  
*/
Scene: string;
/**
This property defines the smoothness with which the camera will move, it only works in a range between 0 and 1

*/
Smoothness: number;
/**
This property defines the object which is going to follow the camera
  
*/
Subject: Character;
/**
Gets the camera position
	
*/
GetPosition(): UDim2;
/**
Sets the camera position
	
*/
SetPosition(udim2: UDim2): null;
/**
Sets the camera subject
	
*/
SetSubject(subject: Character): null;
/**
Position the camera in a centered location relative to the provided object
	
*/
LookTo(object: PhysicalObject): null;
}
 



/**
This class is used in the event emitter class, its used to manage a listener
	
*/ 
export declare interface Connection extends BaseClass {
/**
Defines if the connection is active or not
  
*/
Active: boolean;
/**
The id of the linked event

*/
EventId: number;
/**

*/
Event: { };
/**
Wait until the event gets fired, if seconds were specified, once the specified seconds have elapsed, it will stop waiting
	
*/
Wait(seconds: number | void): thread | void;
/**
Deletes the connection and the listener
	
*/
Disconnect(): null;
}
 



/**
The event emitter is used to manage the events of a class
	
*/ 
export declare interface EventEmitter extends BaseClass {
/**
This table store all the events of the class

*/
EventsStorage: { };
/**

*/
On(name: string, callback: () => any): Connection;
/**

*/
Once(name: string, callback: () => any): Connection;
/**
Triggers an event with the specified arguments
	
*/
Fire(name: string, ...any): null;
}
 



/**
This class is one of the most important components of a scene, is used to manage everything related with the light 
	
*/ 
export declare interface LightingEnvironment extends Environment {
/**
This is the color of every pixel of the ambient, we can say is the darkness color
  
*/
AmbientColor: Color3;
/**
This is the transparency of the ambient, we can say is the darkness transparency
  
*/
AmbientTransparency: number;
/**
This is the seconds between every update of the pixels in the screen
  
*/
UpdateFrequency: number;
/**
This is the intensity for all the lights in the scene
  
*/
LightIntensity: number;
/**
Determines the light rendering mode, there are two modes Enum.ResamplerMode.Pixelated and Enum.ResamplerMode.Default, the default value is Enum.ResamplerMode.Pixelated
  
*/
LightStyle: Enum;
/**
Determines the number of columns for the chunks, the number of rows is calculated automatically, the default value is 1

*/
ChunkColumns: number;
/**
Determines the resolution for every chunk of the screen
  
*/
ChunkResolution: Vector2;
/**
Draws the pixels for the scene with the specified resolution
	
*/
DrawPixels(): null;
/**
Updates the position, the transparency and the color of the ambient
	
*/
UpdateScreen(): null;
}
 



/**

*/ 
export declare interface ObjectEnvironment extends Environment {
}
 



/**

*/ 
export declare interface ParticleEnvironment extends Environment {
}
 



/**
This class is used for the client replication
	
*/ 
export declare interface Request extends EventEmitter {
/**
The content of the request
  
*/
Content: { };
/**
The UserId of the client which sent the request if exists 
	
*/
ClientId: string;
/**
Sends the request to the server
	
*/
Send(content: Dictionary<string, any>): null;
/**
The request is approved and its replicated all the clients
	
*/
Approve(): null;
/**
Accepts the request and builds the object to be replicated
	
*/
Accept(): BaseObject;
/**
Returns the player which sent the request
	
*/
GetClient(): Player;
}
 



/**

*/ 
export declare interface ShaderEnvironment extends Environment {
}
 



/**

*/ 
export declare interface SoundEnvironment extends Environment {
}
 



/**
This class is used for the player character and for npcs
	
*/ 
export declare interface Character extends Sprite {
/**

*/
Anchored: boolean;
/**
The amount of health of the character
  
*/
Health: number;
/**
The maximum amount of health of the character 
  
*/
MaxHealth: number;
/**
The walk speed of the character
  
*/
WalkSpeed: number;
/**
The jump power of the character
  
*/
JumpPower: number;
/**
Set to true when the character is jumping

*/
IsJumping: boolean;
/**
Updates the amount of health of the character 
	
*/
UpdateHealth(Health: number): null;
/**
The character jumps with the provided jump power, if none is provided it will use the JumpPower property as value 
	
*/
Jump(jumpPower: number | void): null;
/**
The character walks directly to the provided position
	
*/
MoveTo(target: Vector2): null;
}
 



/**
This class is used to storage objects and interact with them in an easier way
	
*/ 
export declare interface Environment extends BaseObject {
/**

*/
Content: { };
/**
The amount of objects in this environment

*/
Count: number;
/**
Gets the object with the specified index
	
*/
Get(index: string): any;
/**
Adds an object with the specified index, if no parameter is specified it will use the next number of the count property as index
	
*/
SetOne(value: any, index: string): null;
/**
Adds an object with the specified index, if no parameter is specified it will use the next number of the count property as index
	
*/
AddOne(value: any, index: string): null;
/**
Removes the object with the specified index
	
*/
RemoveOne(index: string): null;
/**
Checks if the environment has a value with the specified index
	
*/
HasOne(index: string): boolean;
/**
Checks if the environment contains every specified index and returns a boolean and a dictionary with boolean values, example:
	```lua
	local hasAll, dictionary = treeEnv:Has({
		"Tree1",
		"Tree2",
		"Tree4"
	})

	print(hasAll, dictionary) -- output: false, { Tree1 = true, Tree2 = true, Tree4 = false }
	```
	
*/
Has(objects: Array<string>): LuaTuple<[boolean, Dictionary<any, boolean>]>
	;
/**
Adds objects with the specified index
	```lua
	treeEnv:Add({
		"Tree1" = tree.new(),
		"Tree2" = tree.new(),
		"Tree3" = tree.new()
	})

	print(treeEnv:Get("Tree2")) -- output: Tree2
	```
	
*/
Add(objects: Dictionary<string, any>): null;
/**
Removes the objects with the specified index, example:
	```lua
	treeEnv:Remove({ "Tree1", "Tree2", "Tree3" })
	print(treeEnv:Get("Tree2")) -- output: nil
	```
	
*/
Remove(objects: Array<string>): null;
/**
Updates the objects with the specified index, example:
	```lua
	treeEnv:Update({
		Tree1 = treeEnv:Get("Tree2"),
		Tree2 = treeEnv:Get("Tree1"),
	})
	```
	
*/
Update(objects: Dictionary<string, any>): null;
/**
Finds an object by his name
	
*/
FindByName(name: string): any;
/**
Sets the specified property in every object in the environment
	
*/
SetProperty(property: string, value: any): null;
/**
Executes the specified methods in every object in the environment with the specified parameters
	
*/
Run(method: string, ...any): null;
}
 



/**
This class is used to simulate fluids
	
*/ 
export declare interface Fluid extends PhysicalObject {
/**
Indicates how much dense the fluid should be. Higher values indicate a denser fluid, 
        affecting buoyancy and movement of objects within the fluid
  
*/
Density: number;
/**
Determines the flow resistance of the fluid. Higher values indicate a thicker fluid, 
        affecting the speed at which objects can move through it
  
*/
Viscosity: number;
/**
Specifies the magnitude of the fluid waves. These waves are not visible but influence buoyancy and object stability.
  
*/
WavesAmplitude: number;
/**
Determines how fast the waves should move

*/
WavesSpeed: number;
}
 



/**
This class is used to illuminate areas in the darkness
	
*/ 
export declare interface Light extends StaticObject {
/**
Is how the light should be shown, there are two modes "PointLight" and "SpotLight"
  
*/
Shape: string;
/**

*/
Rotation: number;
/**

*/
Angle: number;
/**
The color you want the light to have
  
*/
Color: Color3;
/**
Is the range of the light
  
*/
Range: number;
/**
Is the brightness of the light
  
*/
Brightness: number;
/**
!!!warning
  	Only works on Pointlights

  Inverts the light source
  
*/
Inverted: boolean;
}
 



/**
This class is used to create inmersive backgrounds
	
*/ 
export declare interface Parallax extends BaseObject {
/**
Defines the image zoom, if the value is 1X, 1Y it will see the whole image as expected, if you set it to 2X, 2Y you only will be able see half of the image
  
*/
CanvasSize: Vector2;
/**
Defines the scroll position of the parallax object
  
*/
Offset: Vector2;
/**
Defines if Update method should be called automatically
  
*/
Track: boolean;
/**
Locks the Parallax object to the camera position

*/
LockToCamera: boolean;
/**
Sets the tile texture
	
*/
SetTexture(texture: string): null;
/**
Updates the parallax properties (position, canvasSize, etc.), its automatically called when Track is enabled
	
*/
UpdateTiles(): null;
}
 



/**
!!! warning 
  	Currently it's recommended to use sprites to make particles/vfx, this class is in experimental state and can change a lot

  _____
  This class is used for vfx

	
*/ 
export declare interface Particle extends BaseObject {
/**
Depending on the value the particles will be more dispersed
  
*/
Angle: Vector2;
/**
Is the tween info of the tween which is going to be used to move the particles
  
*/
Info: TweenInfo;
/**
!!! warning 
  	Experimental, dont use
  
*/
TrackLight: boolean;
/**
!!! warning 
  	Experimental, dont use
  
*/
CanCollide: boolean;
/**
When its enabled new particles can be emitted
  
*/
Enabled: boolean;
/**
Is the maximum amount of particles that can exist at the same time
  
*/
MaxRate: number;
/**
Is the amount of particles that are existing at this moment
  
*/
Units: number;
/**
!!! warning 
  	Experimental, dont use
  
*/
LightBrightness: number;
/**
!!! warning 
  	Experimental, dont use

*/
LightRange: number;
/**
Is the distance that can be traveled by each particle 
  
*/
Range: number;
/**
The number of seconds the particle will be active before being destroyed
  
*/
LifeTime: number;
/**
Used for internal purposes
  
*/
Clock: number;
/**
Is the amount of particles which is going to be generated
  
*/
Rate: number;
/**
The subject which is going to be the center of emission of the particle, a character, sprite, etc...
  
*/
Subject: Character;
/**
Is a table with the initial properties of the particle which is going to be generated
  
*/
Properties: {
 /**
@desc
*/
["Image"]: string,
};
/**
Is a table with the goals of the particles
  
*/
Goals: {
 /**
@desc
*/
["Size"]: UDim2,
/**
@desc
*/
["ImageTransparency"]: number,
};
/**
Sets the subject property
	
*/
SetSubject(subject: Character): null;
/**
Sets the angle property of the particle
	
*/
SetAngle(Angle: Vector2): null;
/**
Sets the maximum amount of particles that can exist at the same time
	
*/
SetMaxRate(maxRate: number): null;
/**
Emits the specified amount of particles, if none is provided then will use as amount the Rate property
	
*/
Emit(rate: number): null;
}
 



/**
This class is used to create objects with physics
	
*/ 
export declare interface PhysicalObject extends StaticObject {
/**
Is the force which is applied in the moment to the object
  
*/
Force: Vector2;
/**
Is the velocity applied to the object
  
*/
Velocity: Vector2;
/**
Defines the rate of change of velocity for the physical object, initially set to zero.
	
*/
Acceleration: Vector2;
/**
This table stores all the active collisions
  
*/
Collisions: { };
/**
This dictionary stores all the blacklisted objects, to blacklist an object do it like this:
  ```lua
  CollisionBlacklist[object.Id] = true
  ```
  
*/
CollisionBlacklist: { };
/**
This the CollisionMask of the object
  
*/
Hitbox: { };
/**
Specifies the geometric shape of the physical object, which can be "circle" and "custom" for polygons, custom is has box hitbox by default, also is the default shape.
  
*/
Shape: string;
/**
The object mass
  
*/
Mass: number;
/**
Change this property to change the hitbox size, the default value is 1
  
*/
HitboxScale: number;
/**
A number which indicates the collision group of the object, the object only can collide with other objects with the same CollisionGroup
  
*/
CollisionGroup: number;
/**
Determines the resistance to sliding motion between this object and another surface, influencing how quickly it slows down.
  
*/
Friction: number;
/**
This property defines if the object should have physics or not
  
*/
Anchored: boolean;
/**
This property defines if the object can collide with other objects
  
*/
CanCollide: boolean;
/**
This property indicates if the object is touching the ground
  
*/
IsGrounded: boolean;
/**
This property defines if the object is going to have physics and collisions or not
  
*/
TrackCollisions: boolean;
/**
Applies force to the object
	
*/
ApplyForce(force: Vector2): null;
}
 



/**
The proximity prompt is a UI element that will show a prompt when the player is close to it, this is used to interact with objects in the game, it will show a label and a hitbox that will be used to detect when the player is close to it
	
*/ 
export declare interface ProximityPrompt2D extends Sprite {
/**
The range of the prompt, this will be used to detect when the prompt should be shown
        
*/
Range: number;
/**
The action name of the prompt, this will be used to detect when the 
        prompt is triggered, if you change the default action name you should change or 
        add a new action in the CrossPlatformService, 'Interact' by default
  
*/
ActionName: string;
/**
If the prompt is enabled or not, if it is not enabled the prompt will not be shown
  
*/
Enabled: boolean;
/**
True if the proximity prompt is the closest one to the player
  
*/
IsClosest: boolean;
/**
True if the proximity prompt is visible on the player's screen. Useful for detecting when the prompt is within interaction range
        
*/
InRange: boolean;
/**
Determines whether this proximity prompt should only be shown when it is the closest one to the player.
  If set to true, the prompt will only appear if it is the nearest among all prompts within interaction range.
  If set to false, the prompt will be shown as long as it is within range, regardless of other nearby prompts.
  The property is enabled by default
	
*/
ShowIfClosest: boolean;
/**
The duration of the fade in and out of the prompt, this will be used to make the prompt appear and disappear smoothly
  
*/
FadeDuration: number;
/**
The text label of the prompt, this will be shown when the prompt is active
        
*/
Label: Instance;
/**
The button that will be used to trigger the proximity prompt on mobile devices
  
*/
HitboxButton: Instance;
/**

*/
SecondsPerFrame: number;
/**

*/
Name: string;
/**
A table containing the positions(as UDim2) of the label, this will be used to adjust the text to the proximity prompt sprites, position 0 will be the position on the first frame, position 1 will be the position on the second frame, etc.
  
*/
LabelPositions: { };
}
 



/**
UI element that renders text with a typewriter effect, text animations and supports roblox rich text. 
	
*/ 
export declare interface ReactiveLabel extends BaseObject {
/**
The font used for displaying text.
  
*/
Font: Enum;
/**
The font size of the text.
  
*/
FontSize: number;
/**
The text content to be rendered.
  
*/
Text: string;
/**

*/
TextTransparency: number;
/**

*/
TextColor3: Color3;
/**
Determines if the text scales automatically.
  
*/
TextScaled: boolean;
/**
If true, renders text progressively like a typewriter.
  
*/
Animated: boolean;
/**

*/
TextStrokeColor3: Color3;
/**
Transparency of the text stroke.
  
*/
TextStrokeTransparency: number;
/**
Thickness of the text stroke.
  
*/
TextStrokeThickness: number;
/**
 The number of characters rendered per second.
  
*/
CharactersPerSecond: number;
/**
The volume of the typing sound.
  
*/
TypingSoundVolume: number;
/**
If true, stops the typing sound once rendering is complete.
  
*/
StopSoundOnFinish: boolean;
/**
A table defining additional pause durations after certain characters (e.g., comma, period).
  -- Example of PauseDelays usage:
  {
  	[","] = 0.25, -- pause 0.25 seconds after a comma
  	["."] = 0.5,  -- pause 0.5 seconds after a period
  	["?"] = 0.5,  -- pause 0.5 seconds after a question mark
  }

*/
PauseDelays: {
 /**
@desc
*/
[","]: number,
/**
@desc
*/
["."]: number,
/**
@desc
*/
["?"]: number,
};
/**

*/
Size: UDim2;
/**

*/
BackgroundTransparency: number;
/**
Renders the label text with a typewriter effect, yielding during animations.
	
*/
Render(): null;
}
 



/**
This class is useful to have a workspace and manage your project more easily
	
*/ 
export declare interface Scene extends BaseObject {
/**
The scene gravity
  
*/
Gravity: Vector2;
/**
This property defines whether physics should be calculated only for visible objects
  
*/
OnlyTrackVisible: boolean;
/**
The scene camera
  
*/
Camera: Camera;
/**
This is the LightingEnvironment of the scene
  
*/
LightingEnvironment: LightingEnvironment;
/**
This is the ParticleEnvironment of the scene
  
*/
ParticleEnvironment: ParticleEnvironment;
/**
This is the SoundEnvironment of the scene
  
*/
SoundEnvironment: SoundEnvironment;
/**
This is the ShaderEnvironment of the scene

*/
ShaderEnvironment: ShaderEnvironment;
/**
This environment stores all the objects in the scene
  
*/
Objects: ObjectEnvironment;
/**
Enables the scene, which will make it process physics, lights, sounds and sprites
	
*/
Enable(): null;
/**
Disables the scene
	
*/
Disable(): null;
/**
Gets all the objects with the provided tags in the scene
	
*/
GetTaggedObjects(tag: string): Array<string>;
/**
Casts a ray using the Raycast2dParams. If it finds an elegible object a Raycast2dResult is returned containing the results of the operations
	
*/
Raycast(info: Raycast2dParams): Raycast2dResult;
}
 



/**
!!! warning 
  	Shaders are very cpu-intensive, so it is not recommended to use them with high resolution images
  	and not to use too many shaders.

  	If you need to scale an image, do it in the studio, instead of doing it in the editing program, 
  	this will lighten a lot the work for the cpu.	

  _____
  This class is used to modify how an object is renderized
	
*/ 
export declare interface Shader extends BaseClass {
/**
This property determines if the shader is enabled
  
*/
Enabled: boolean;
/**
When this property is marked as true every animation of a sprite will be preloaded, 
  if not the animations will be loaded dynamically
  
*/
PreloadSprites: boolean;
/**
This property determines if the shader will use the mirror source or not, false by default
        
*/
MirrorEnabled: boolean;
/**
The current mirror source, nil by default ImageLabel if an object is set using SetMirrorSource()
  
*/
MirrorSource: ImageLabel;
/**
Sometimes, modifying the position of pixels in an image can create gaps.
  Upside Engine automatically fills these gaps, but this can occasionally 
  lead to unwanted effects. Therefore, adjust this property according to your needs, 
  the value of this property ranges between 0 and 1.

*/
Precision: number;
/**
This property stores the shader path
        
*/
Path: string;
/**
Sets the mirror source object for rendering the shader. When a mirror source is specified, 
 the shader uses its `ImageRectOffset` and `ImageRectSize` to render. All objects to which this shader
 is applied will display the exact same result, mirroring the appearance of the source object. 
 If no mirror source is set, each object will be rendered independently, 
 which may lead to decreased performance.
	
*/
SetMirrorSource(object: StaticObject): null;
/**
Sets the module script which is going to be used as shader source
	
*/
SetSource(file: ModuleScript): null;
}
 



/**
This class is used to play sounds
	
*/ 
export declare interface Sound extends BaseObject {
/**
This is the SoundEnvironment of the scene
  
*/
Range: number;
/**
This is the ParticleEnvironment of the scene
  
*/
MaxVolume: number;
/**
The volume will depend on the player distance

*/
DistanceFading: boolean;
/**
This table stores all the objects in the scene
  
*/
Subject: Character;
/**
Sets the provided character as subject, if is provided a sound group, this will be the new sound group of the sound
	
*/
SetSubject(subject: Character, useSceneSoundGroup: boolean | void): null;
}
 



/**
This class is used to play sounds
	
*/ 
export declare interface Sprite extends PhysicalObject {
/**
Indicates if the sprite is playing
  
*/
IsPlaying: boolean;
/**
This is the time to wait between frame and frame
  
*/
SecondsPerFrame: number;
/**
This table stores all sprite sheets and sprite lists 
  
*/
Sprites: { };
/**
This table stores information about the active spritesheet
	
*/
Active: {
 /**
@desc
*/
["Name"]: string,
/**
@desc
*/
["CurrentFrame"]: Vector2,
/**
@desc
*/
["SecondsPerFrame"]: number,
/**
@desc
*/
["NextStepReady"]: boolean,
};
/**
Adds a new sprite sheet to the object, the sprite will be played using as reference the amount of cells in the X axe and the Y axe, this must be provided in the third paramether as a Vector2
	
*/
SetSpriteSheet(name: string, url: string, frames: Vector2): null;
/**
Adds a new sprite list to the object, it will play the animation using the order in the provided list, this list must contain the urls of every frame
	
*/
SetSpriteList(name: string, list: Array<string>): null;
/**
Plays the specified sprite if exists, if secondsEveryFrame is specified it will be used instead of .SecondsPerFrame
	
*/
Play(name: string, secondsPerFrame: number | void): null;
/**
Stops the reproduction of the current playing sprite sheet or sprite list
	
*/
Stop(): null;
}
 



/**
This class is used to create a basic object, without physics or animations
	
*/ 
export declare interface StaticObject extends BaseObject {
/**
This is the point which is being used as reference for the chromatic aberration
  
*/
ChromaticAberrationPoint: Vector2;
/**
The instances which makes the chromatic aberration effect
  
*/
ChromaticAberration: { };
/**
Is the shader of the object

*/
Shader: Shader;
/**

*/
ChromaticAberrationIntensity: number;
/**

*/
ChromaticAberrationDistance: number;
/**

*/
ChromaticAberrationConnection: boolean;
/**
Sets the scene for this object
	
*/
SetScene(scene: Scene): null;
/**
Sets the shader for this object
	
*/
SetShader(shader: Shader): null;
/**
Loads an image for the current object and is set as the instance image
	
*/
Load(url: string): null;
/**
Sets chromatic aberration for the image using a center as reference, by default the center is the middle of the screen, 
 to disable the chromatic aberration send 0 as first parameter
 
*/
SetChromaticAberration(Intensity: number, Distance: number, Point: Vector2): null;
}
 



/**
Class representing a text tag for UpsideEngine.
	
*/ 
export declare interface TextTag extends BaseClass {
/**
The tag name that defines a rendering style.
  
*/
TagName: string;
/**
Display mode, either "letter" (character by character) or "word" (word by word).
  
*/
DisplayMode: string;
/**
Volume of the typing sound.
  
*/
TypingSoundVolume: number;
/**
Typing speed expressed in words per second.
  
*/
WordsPerSecond: number;
/**
Idle time.
  
*/
IdleTime: number;
}
 



/**
This class is used to make the controls functional in any device (Keyboards, Mobiles, Gamepads), this service vinculate actions 
 to specified keys, and also provides a movement system for the player character which can be disabled with the `DefaultControllersEnabled`
 property, here is an example to make our player jumps in every device:
```lua
--  								Device,	    Key, 	Action
CrossPlatformService:SetDeviceKey("Keyboard", "Space", "Up")
CrossPlatformService:SetDeviceKey("Mobile", "JumpButton", "Up")
CrossPlatformService:SetDeviceKey("Gamepad", "ButtonA", "Up")
```


But this is not limited only to movement actions, you can also assign other kind of actions, for example:


```lua
CrossPlatformService:SetDeviceKey("Keyboard", "E", "Collect")
CrossPlatformService:SetDeviceKey("Mobile", "JumpButton", "Collect")
CrossPlatformService:SetDeviceKey("Gamepad", "ButtonA", "Collect")
```


We assigned an action for our devices but how can we detect when an action is triggered? well we can listen to three events
"InputBegin", "InputChange", "InputEnd", example of use:


```lua
-- If the movement belongs to a stick, the second parameter will give the current position of the stick
CrossPlatformService:On("InputBegin", function(inputObject)
	local character = CrossPlatformService.Character

	if inputObject.Action == "Up" then
		character:Jump(150)
	end
end)
```

	
*/ 
export declare interface CrossPlatformService extends EventEmitter {
/**
Defines if the default movement system is enabled
  
*/
DefaultControllersEnabled: boolean;
/**
Defines if the character is going to be seen from the side or from the top
  
*/
SideView: boolean;
/**
This is the sensibility of the sticks in mobile and in game controllers
  
*/
StickSensibility: number;
/**
This is the character which is going to be tracked by the camera
  
*/
Character: Character;
/**
This table stores the default controllers
	
*/
Configs: {
 /**
@desc
*/
["Keyboard"]: {
 	/**
@desc
*/
["W"]: string,
	/**
@desc
*/
["A"]: string,
	/**
@desc
*/
["S"]: string,
	/**
@desc
*/
["D"]: string,
	/**
@desc
*/
["Up"]: string,
	/**
@desc
*/
["Left"]: string,
	/**
@desc
*/
["Down"]: string,
	/**
@desc
*/
["Right"]: string,
	/**
@desc
*/
["Space"]: string,
	/**
@desc
*/
["E"]: string,
	},
/**
@desc
*/
["Gamepad"]: {
 	/**
@desc
*/
["ButtonA"]: string,
	/**
@desc
*/
["ButtonX"]: string,
	/**
@desc
*/
["Thumbstick1"]: {
 		/**
@desc
*/
["Up"]: string,
		/**
@desc
*/
["Left"]: string,
		/**
@desc
*/
["Down"]: string,
		/**
@desc
*/
["Right"]: string,
		},
	},
/**
@desc
*/
["Mobile"]: {
 	/**
@desc
*/
["JumpButton"]: string,
	/**
@desc
*/
["Thumbstick1"]: {
 		/**
@desc
*/
["Up"]: string,
		/**
@desc
*/
["Left"]: string,
		/**
@desc
*/
["Down"]: string,
		/**
@desc
*/
["Right"]: string,
		},
	},
};
/**
Detects the current device type based on user input capabilities
	
*/
DetectCurrentDevice(): string;
/**
Returns the current key for a specific action based on the current device (Mobile, Gamepad, or Keyboard)
	
*/
GetTargetActionKey(action: string): string | void;
/**
Assigns an action to a device key, example:
	```lua
	CrossPlatformService:SetDeviceKey("Keyboard", "Space", "Up")
	```
	
*/
SetDeviceKey(device: string, key: string, action: string): null;
/**
Sets the entire configuration of a device, example:
	```lua
	CrossPlatformService:SetDeviceConfig("Keyboard", {
		W = "Up",
		A = "Left",
		S = "Down",
		D = "Right",

		Up = "Up",
		Left = "Left",
		Down = "Down",
		Right = "Right",
		Space = "Up",
	})
	```
	
*/
SetDeviceConfig(device: string, controls: Dictionary<string, string>): null;
/**
Sets the player character
	
*/
SetPlayerCharacter(character: Character): null;
}
 



/**
This class is used to replicate objects to other clients, for example the player character
	
*/ 
export declare interface NetworkingService extends EventEmitter {
/**
Specifies the number of replication requests per second to send when using ReplicateOnChange
  
*/
ReplicationPerSecond: number;
/**
If true, destroys replicated objects from other clients when they leave
  
*/
DestroyObjectsOnLeave: boolean;
/**
Table of objects from other clients currently targeted for replication
  
*/
ReplicationTarget: { };
/**
Dictionary containing the replicated objects for each client (keyed by UserId)
  
*/
PlayersData: { };
/**

*/
Cache: { };
/**
Replicates an object to other clients

*/
Replicate(object: BaseObject): null;
/**
Replicates an object and each change on it, and returns the connections that detect each change of the object
	
*/
ReplicateOnChange(object: BaseObject): LuaTuple<[Connection, Connection]>
;
}
 



/**
This class save and build the engine data

*/ 
export declare interface PluginSupportService extends EventEmitter {
/**
Loads the engine data stored in the "UpsideEngineDB" attribute of replicated storage, when it ends sets the attribute as an empty table
	
*/
LoadPluginContent(): null;
/**
Saves the engine data in replicated storage as attribute with the name "UpsideEngineDB" can be useful to create plugins
	
*/
SavePluginContent(content: {}): null;
}
 



/**
This class save and build the engine data
	
*/ 
export declare interface SceneManager extends EventEmitter {
/**

*/
Scenes: { };
/**
This dictionary stores all the active scenes
	
*/
ActiveScenes: { };
/**
Finds a scene by the name
	
*/
FindByName(name: string): Scene | void;
/**
Returns the scene with the specified Id
	
*/
Get(Id: string): Scene;
}
 



/**

*/ 
export declare interface TextTagService extends BaseClass {
/**

*/
TextTags: { };
}
 



interface upsideEngine {
	Version: string;
	Workspace: {};
	new: ((name: "PhysicalObject") => PhysicalObject)
		& ((name: "Sprite") => Sprite)
		& ((name: "StaticObject") => StaticObject)
		& ((name: "Fluid") => Fluid)
		& ((name: "Parallax") => Parallax)
		& ((name: "Sound") => Sound)
		& ((name: "Environment") => Environment)
		& ((name: "Light") => Light)
		& ((name: "Character") => Character)
		& ((name: "Scene") => Scene)
		& ((name: "Particle") => Particle)
		& ((name: "Shader") => Shader)
		& ((name: "TextTag") => TextTag)
		& ((name: "ReactiveLabel") => ReactiveLabel)
		& ((name: "ProximityPrompt2D") => ProximityPrompt2D),


	GetService: ((name: "SceneManager") => SceneManager)
		& ((name: "PluginSupportService") => PluginSupportService)
		& ((name: "NetworkingService") => NetworkingService)
		& ((name: "TextTagService") => TextTagService)
		& ((name: "CrossPlatformService") => CrossPlatformService),
}

declare const UpsideEngine: upsideEngine;
export default UpsideEngine;