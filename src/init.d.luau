-- THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
export type table = {}
export type Dictionary<k, v> = {}
export type Array<v> = {}
export type ChromaticAberrationConnection = {}

export type Event = {
	Functions: table,
	Threads: table,
}

export type RequestContent = {
	className: string,
	id: string,
	name: string,
	properties: {
		instance: table,
		object: table,
	},
}

export type Raycast2dResult = {
	Object: PhysicalObject,
	Position: UDim2,
	Distance: Vector2,
	Normal: UDim2,
}

export type Raycast2dParams = {
	FilterType: string,
	From: Vector2,
	List: Array<BaseObject>,
	To: Vector2,
}

export type BaseClass = {
	Id: string,
	ClassName: string,
	Name: string,
	new: () -> BaseClass,
	SetName: (self: BaseClass, name: string) -> (),
	IsA: (self: BaseClass, className: string) -> boolean,
	Clone: (self: BaseClass, ...any) -> BaseClass,
	Destroy: (self: BaseClass) -> (),
}
--[[
This class is the base class of the majority of classes
	]]
export type BaseObject = EventEmitter & {
--[[
The object instance
		]]
Instance: Instance,
--[[
The object scene ID
		]]
Scene: string,
--[[
This table stores all the tags of the object
]]
Tags: 	{ 	},
--[[
]]
new: (instanceType: string?) -> BaseObject,
--[[
Sets the object scene
	]]
SetScene: (self: BaseObject, scene: Scene) -> nil,
--[[
Adds a tag to the object
	]]
AddTag: (self: BaseObject, tag: string) -> nil,
--[[
Checks if the object contain the specified tag
	]]
HasTag: (self: BaseObject, tag: string) -> boolean,
--[[
Removes a tag from the object
	]]
RemoveTag: (self: BaseObject, tag: string) -> nil,
}




--[[
This class is included on every scene, it's used to move you around the scene
	]]
export type Camera = EventEmitter & {
--[[
This property is used to move the camera internally
		]]
LocalPosition: Vector2,
--[[
This property marks the limits to move the camera, for example, if you set `Vector2.new(0.5, 0.5)` the camera will move only when it reaches the limit
		]]
Limits: Vector2,
--[[
This property defines if the camera is going to follow the defined subject
]]
FollowSubject: boolean,
--[[
]]
Scene: string,
--[[
This property defines the object which is going to follow the camera
		]]
Subject: Character,
--[[
]]
new: (scene: Scene) -> Camera,
--[[
Gets the camera position
	]]
GetPosition: (self: Camera) -> nil,
--[[
Sets the camera position
	]]
SetPosition: (self: Camera, udim2: UDim2) -> nil,
--[[
Sets the camera subject
	]]
SetSubject: (self: Camera, subject: Character) -> nil,
--[[
]]
LookTo: (self: Camera, object: PhysicalObject) -> nil,
}




--[[
This class is used in the event emitter class, its used to manage a listener
	]]
export type Connection = BaseClass & {
--[[
Defines if the connection is active or not
]]
Active: boolean,
--[[
]]
EventId: number,
--[[
]]
Event: 	{ 	},
--[[
]]
new: (eventId: number, event: table) -> Connection,
--[[
Wait until the event gets fired, if seconds were specified, once the specified seconds have elapsed, it will stop waiting
	]]
Wait: (self: Connection, seconds: number?) -> thread?,
--[[
Deletes the connection and the listener
	]]
Disconnect: (self: Connection) -> nil,
}




--[[
The event emitter is used to manage the events of a class
	]]
export type EventEmitter = BaseClass & {
--[[
This table store all the events of the class
]]
EventsStorage: 	{ 	},
--[[
]]
new: () -> EventEmitter,
--[[
]]
On: (self: EventEmitter, name: string, callback: () -> any) -> Connection,
--[[
Triggers an event with the specified arguments
	]]
Fire: (self: EventEmitter, name: string, ...any) -> nil,
}




--[[
This class is one of the most important components of a scene, is used to manage everything related with the light 
	]]
export type LightingEnvironment = Environment & {
--[[
This is the color of every pixel of the ambient, we can say is the darkness color
		]]
AmbientColor: Color3,
--[[
This is the transparency of the ambient, we can say is the darkness transparency
		]]
AmbientTransparency: number,
--[[
This is the seconds between every update of the pixels in the screen
		]]
UpdateFrequency: number,
--[[
This is the intensity for all the lights in the scene
]]
LightIntensity: number,
--[[
]]
new: (scene: Scene) -> LightingEnvironment,
--[[
Draws the pixels for the scene with the specified pixel size
	]]
DrawPixels: (self: LightingEnvironment, pixelSize: number) -> nil,
--[[
Updates the position, the transparency and the color of the ambient
	]]
UpdateScreen: (self: LightingEnvironment) -> nil,
}




--[[
]]
export type ObjectEnvironment = Environment & {
--[[
]]
new: () -> ObjectEnvironment,
}




--[[
]]
export type ParticleEnvironment = Environment & {
--[[
]]
new: () -> ParticleEnvironment,
}




--[[
This class is used for the client replication
	]]
export type Request = EventEmitter & {
--[[
The UserId of the client which sent the request if exists 
	]]
ClientId: number,
--[[
The content of the request
		]]
Content: 	{ 	},
--[[
]]
new: (clientId: number?, content: RequestContent?) -> Request,
--[[
Sends the request to the server
	]]
Send: (self: Request, content: Dictionary<string, any>) -> nil,
--[[
The request is approved and its replicated to the specified clients, if none is specified it will be replicated to all the clients except to the client who sent the request
	]]
Approve: (self: Request, clients: table) -> nil,
--[[
Accepts the request and builds the object to be replicated
	]]
Accept: (self: Request) -> nil,
--[[
Returns the player which sent the request
	]]
GetClient: (self: Request) -> nil,
}




--[[
]]
export type SoundEnvironment = Environment & {
--[[
]]
new: () -> SoundEnvironment,
}




--[[
This class is used for the player character and for npcs
	]]
export type Character = Sprite & {
--[[
The amount of health of the character
		]]
Health: number,
--[[
The maximum amount of health of the character 
		]]
MaxHealth: number,
--[[
The walk speed of the character
		]]
WalkSpeed: number,
--[[
The jump power of the character
]]
JumpPower: number,
--[[
]]
new: () -> Character,
--[[
Updates the amount of health of the character 
	]]
UpdateHealth: (self: Character, Health: number) -> nil,
--[[
The character jumps with the provided jump power, if none is provided it will use the JumpPower property as value 
	]]
Jump: (self: Character, jumpPower: number?) -> nil,
--[[
The character walks directly to the provided position
	]]
MoveTo: (self: Character, target: Vector2) -> nil,
}




--[[
This class is used to storage objects and interact with them in an easier way
	]]
export type Environment = BaseObject & {
--[[
]]
Content: 	{ 	},
--[[
The amount of objects in this environment
]]
Count: number,
--[[
]]
new: (instanceType: string?) -> Environment,
--[[
]]
__iter: (self: Environment) -> nil,
--[[
Gets the object with the specified index
	]]
Get: (self: Environment, index: string) -> any,
--[[
Adds an object with the specified index, if no parameter is specified it will use the next number of the count property as index
	]]
SetOne: (self: Environment, value: any, index: string) -> nil,
--[[
Adds an object with the specified index, if no parameter is specified it will use the next number of the count property as index
	]]
AddOne: (self: Environment, value: any, index: string) -> nil,
--[[
Removes the object with the specified index
	]]
RemoveOne: (self: Environment, index: string) -> nil,
--[[
Checks if the environment has a value with the specified index
	]]
HasOne: (self: Environment, index: string) -> boolean,
--[[
Checks if the environment contains every specified index and returns a boolean and a dictionary with boolean values, example:
	]]
Has: (self: Environment, objects: Array<string>) -> (boolean, Dictionary<string, boolean>),
--[[
Adds objects with the specified index
	```lua
	treeEnv:Add({
		"Tree1" = tree.new(),
		"Tree2" = tree.new(),
		"Tree3" = tree.new()
	})

	print(treeEnv:Get("Tree2")) -- output: Tree2
	```
	]]
Add: (self: Environment, objects: Dictionary<string, any>) -> nil,
--[[
Removes the objects with the specified index, example:
	```lua
	treeEnv:Remove({ "Tree1", "Tree2", "Tree3" })
	print(treeEnv:Get("Tree2")) -- output: nil
	```
	]]
Remove: (self: Environment, objects: Array<string>) -> nil,
--[[
Updates the objects with the specified index, example:
	```lua
	treeEnv:Update({
		Tree1 = treeEnv:Get("Tree2"),
		Tree2 = treeEnv:Get("Tree1"),
	})
	```
	]]
Update: (self: Environment, objects: Dictionary<string, any>) -> nil,
--[[
Finds an object by his name
	]]
FindByName: (self: Environment, name: string) -> any,
--[[
Sets the specified property in every object in the environment
	]]
SetProperty: (self: Environment, property: string, value: any) -> nil,
--[[
Executes the specified methods in every object in the environment with the specified parameters
	]]
Run: (self: Environment, method: string, ...any) -> nil,
}




--[[
This class is used to illuminate areas in the darkness
	]]
export type Light = PhysicalObject & {
--[[
Its a property of PhysicalObject, in this class is marked as readonly and is set false to optimizate
		]]
TrackCollisions: boolean,
--[[
]]
Color: Color3,
--[[
Is the range of the light
		]]
Range: number,
--[[
Is the brightness of the light
		]]
Brightness: number,
--[[
]]
Transparency: number,
--[[
]]
new: () -> Light,
}




--[[
!!! warning 
		Currently it's recommended to use sprites to make particles/vfx, this class is in experimental state and can change a lot

		_____
		This class is used for vfx

	]]
export type Particle = BaseObject & {
--[[
Depending on the value the particles will be more dispersed
		]]
Angle: Vector2,
--[[
Is the tween info of the tween which is going to be used to move the particles
		]]
Info: TweenInfo,
--[[
!!! warning 
			Experimental, dont use
		]]
TrackLight: boolean,
--[[
!!! warning 
			Experimental, dont use
		]]
CanCollide: boolean,
--[[
When its enabled new particles can be emitted
		]]
Enabled: boolean,
--[[
Is the maximum amount of particles that can exist at the same time
		]]
MaxRate: number,
--[[
Is the amount of particles that are existing at this moment
		]]
Units: number,
--[[
!!! warning 
			Experimental, dont use
		]]
LightBrightness: number,
--[[
!!! warning 
			Experimental, dont use
]]
LightRange: number,
--[[
Is the distance that can be traveled by each particle 
		]]
Range: number,
--[[
The number of seconds the particle will be active before being destroyed
		]]
LifeTime: number,
--[[
Used for internal purposes
		]]
Clock: number,
--[[
Is the amount of particles which is going to be generated
		]]
Rate: number,
--[[
The subject which is going to be the center of emission of the particle, a character, sprite, etc...
		]]
Subject: Character,
--[[
Is a table with the initial properties of the particle which is going to be generated
		]]
Properties: 	{ 	},
--[[
Is a table with the goals of the particles
		]]
Goals: 	{ 	},
--[[
]]
new: () -> Particle,
--[[
Sets the subject property
	]]
SetSubject: (self: Particle, subject: Character) -> nil,
--[[
Sets the angle property of the particle
	]]
SetAngle: (self: Particle, Angle: Vector2) -> nil,
--[[
Sets the maximum amount of particles that can exist at the same time
	]]
SetMaxRate: (self: Particle, maxRate: number) -> nil,
--[[
Emits the specified amount of particles, if none is provided then will use as amount the Rate property
	]]
Emit: (self: Particle, rate: number) -> nil,
}




--[[
This class is used to create objects with physics
	]]
export type PhysicalObject = BaseObject & {
--[[
This is the point which is being used as reference for the chromatic aberration
		]]
ChromaticAberrationPoint: Vector2,
--[[
Is the force which is applied in the moment to the object
		]]
Force: Vector2,
--[[
Is the velocity applied to the object
		]]
Velocity: Vector2,
--[[
The instances which makes the chromatic aberration effect
		]]
ChromaticAberration: 	{ 	},
--[[
This table stores all the active collisions
		]]
Collisions: 	{ 	},
--[[
This dictionary stores all the blacklisted objects, to blacklist an object do it like this:
		```lua
		CollisionBlacklist[object.Id] = true
		```
		]]
CollisionBlacklist: 	{ 	},
--[[
!!! warning 
			Experimental, dont use
		]]
Hitbox: 	{ 	},
--[[
The object mass
		]]
Mass: number,
--[[
]]
HitboxScale: number,
--[[
A number which indicates the collision group of the object, the object only can collide with other objects with the same CollisionGroup
		]]
CollisionGroup: number,
--[[
]]
ChromaticAberrationIntensity: number,
--[[
]]
ChromaticAberrationDistance: number,
--[[
This property defines if the object should have physics or not
		]]
Anchored: boolean,
--[[
This property defines if the object can collide with other objects
		]]
CanCollide: boolean,
--[[
This property indicates if the object is touching the ground
		]]
IsGrounded: boolean,
--[[
This property defines if the object is going to have physics and collisions or not
		]]
TrackCollisions: boolean,
--[[
]]
ConstantVelocityEnabled: boolean,
--[[
]]
ChromaticAberrationConnection: boolean,
--[[
]]
new: () -> PhysicalObject,
--[[
!!! warning 
		Sets the hitbox shape. Experimental, dont use
	]]
SetHitboxShape: (self: PhysicalObject, shape: string) -> nil,
--[[
Loads an image for the current object and is set as the instance image
	]]
Load: (self: PhysicalObject, url: string) -> nil,
--[[
Sets chromatic aberration for the image using a center as reference, by default the center is the middle of the screen, 
	to disable the chromatic aberration send 0 as first parameter
	]]
SetChromaticAberration: (self: PhysicalObject, Intensity: number, Distance: number, Point: Vector2) -> nil,
}




--[[
This class is useful to have a workspace and manage your project more easily
	]]
export type Scene = BaseObject & {
--[[
]]
Camera: Camera,
--[[
This is the LightingEnvironment of the scene
]]
LightingEnvironment: LightingEnvironment,
--[[
This is the ParticleEnvironment of the scene
		]]
ParticleEnvironment: ParticleEnvironment,
--[[
This is the SoundEnvironment of the scene
		]]
SoundEnvironment: SoundEnvironment,
--[[
This table stores all the objects in the scene
		]]
Objects: ObjectEnvironment,
--[[
]]
new: () -> Scene,
--[[
]]
Enable: (self: Scene) -> nil,
--[[
]]
Disable: (self: Scene) -> nil,
--[[
Gets all the objects with the provided tags in the scene
	]]
GetTaggedObjects: (self: Scene, tag: string) -> Array<string>,
--[[
Casts a ray using the Raycast2dParams. If it finds an elegible object a Raycast2dResult is returned containing the results of the operations
	]]
Raycast: (self: Scene, info: Raycast2dParams) -> Raycast2dResult,
}




--[[
This class is used to play sounds
	]]
export type Sound = BaseObject & {
--[[
This is the SoundEnvironment of the scene
		]]
Range: number,
--[[
This is the ParticleEnvironment of the scene
		]]
MaxVolume: number,
--[[
The volume will depend on the player distance
]]
DistanceFading: boolean,
--[[
This table stores all the objects in the scene
		]]
Subject: Character,
--[[
]]
new: () -> Sound,
--[[
Sets the provided character as subject, if is provided a sound group, this will be the new sound group of the sound
	]]
SetSubject: (self: Sound, subject: Character, useSceneSoundGroup: boolean?) -> nil,
}




--[[
This class is used to play sounds
	]]
export type Sprite = PhysicalObject & {
--[[
Indicates if the sprite is playing
		]]
IsPlaying: boolean,
--[[
This is the time to wait between frame and frame
		]]
SecondsPerFrame: number,
--[[
This table stores all sprite sheets and sprite lists 
		]]
Sprites: 	{ 	},
--[[
This table stores information about the active spritesheet
]]
Active: 	{ 	},
--[[
The second parameter is the size of a cell of every frame of an sprite sheet, this can be changed using the .ImageRectSize property of the object Instance 
	]]
new: () -> Sprite,
--[[
Adds a new sprite sheet to the object, the sprite will be played using as reference the amount of cells in the X axe and the Y axe, this must be provided in the third paramether as a Vector2
	]]
SetSpriteSheet: (self: Sprite, name: string, url: string, frames: Vector2) -> nil,
--[[
Adds a new sprite list to the object, it will play the animation using the order in the provided list, this list must contain the urls of every frame
	]]
SetSpriteList: (self: Sprite, name: string, list: Array<string>) -> nil,
--[[
Plays the specified sprite if exists, if secondsEveryFrame is specified it will be used instead of .SecondsPerFrame
	]]
Play: (self: Sprite, name: string, secondsPerFrame: number?) -> nil,
--[[
Stops the reproduction of the current playing sprite sheet or sprite list
	]]
Stop: (self: Sprite) -> nil,
}




--[[
This class is used to make the controls functional in any device (Keyboards, Mobiles, Gamepads), this service vinculate actions 
	to specified keys, and also provides a movement system for the player character which can be disabled with the `DefaultControllersEnabled`
	property, here is an example to make our player jumps in every device:
```lua
--  								Device,	    Key, 	Action
CrossPlatformService:SetDeviceKey("Keyboard", "Space", "Jump")
CrossPlatformService:SetDeviceKey("Mobile", "JumpButton", "Jump")
CrossPlatformService:SetDeviceKey("Gamepad", "ButtonA", "Jump")
```


But this is not limited only to movement actions, you can also assign other kind of actions, for example:


```lua
CrossPlatformService:SetDeviceKey("Keyboard", "E", "Collect")
CrossPlatformService:SetDeviceKey("Mobile", "JumpButton", "Collect")
CrossPlatformService:SetDeviceKey("Gamepad", "ButtonA", "Collect")
```


We assigned an action for our devices but how can we detect when an action is triggered? well we can listen to three events
"InputBegin", "InputChange", "InputEnd", example of use:


```lua
-- If the movement belongs to a stick, the second parameter will give the current position of the stick
CrossPlatformService:On("InputBegin", function(action, position)
	local character = CrossPlatformService.Character

	if action == "Jump" then
		character:Jump(150)
	end
end)
```

	]]
export type CrossPlatformService = EventEmitter & {
--[[
Defines if the default movement system is enabled
		]]
DefaultControllersEnabled: boolean,
--[[
Defines if the character is going to be seen from the side or from the top
		]]
SideView: boolean,
--[[
This is the sensibility of the sticks in mobile and in game controllers
		]]
StickSensibility: number,
--[[
This is the character which is going to be tracked by the camera
		]]
Character: Character,
--[[
This table stores the default controllers
	]]
Configs: 	{
 --[[
@desc]]
Keyboard: 	{ 	},
--[[
@desc]]
Gamepad: 	{
 --[[
@desc]]
Thumbstick1: 	{ 	},
	},
--[[
@desc]]
Mobile: 	{
 --[[
@desc]]
Thumbstick1: 	{ 	},
	},
	},
--[[
]]
new: () -> CrossPlatformService,
--[[
Assigns an action to a device key, example:
	```lua
	CrossPlatformService:SetDeviceKey("Keyboard", "Space", "Jump")
	```
	]]
SetDeviceKey: (self: CrossPlatformService, device: string, key: string, action: string) -> nil,
--[[
Sets the entire configuration of a device, example:
	```lua
	CrossPlatformService:SetDeviceConfig("Keyboard", {
		W = "Up",
		A = "Left",
		S = "Down",
		D = "Right",

		Up = "Up",
		Left = "Left",
		Down = "Down",
		Right = "Right",
		Space = "Jump",
	})
	```
	]]
SetDeviceConfig: (self: CrossPlatformService, device: string, controls: Dictionary<string, string>) -> nil,
--[[
Sets the player character
	]]
SetPlayerCharacter: (self: CrossPlatformService, character: Character) -> nil,
}




--[[
This class is to replicate objects to other clients, for example the player character
	]]
export type NetworkingService = EventEmitter & {
--[[
A dictionary with the replicated objects by the clients
		]]
Players: 	{ 	},
--[[
Defines if the replicated objects by other clients should be destroyed when they leaves
	]]
DestroyObjectsOnLeave: boolean,
--[[
]]
new: () -> NetworkingService,
--[[
Replicates an object to other clients
]]
Replicate: (self: NetworkingService, object: BaseObject) -> nil,
--[[
Replicates an object and each change on it, and returns the connections that detect each change of the object
	]]
ReplicateOnChange: (self: NetworkingService, object: BaseObject) -> RBXScriptConnection,
}




--[[
This class save and build the engine data
]]
export type PluginSupportService = EventEmitter & {
--[[
]]
new: () -> PluginSupportService,
--[[
Loads the engine data stored in the "UpsideEngineDB" attribute of replicated storage, when it ends sets the attribute as an empty table
	]]
LoadPluginContent: (self: PluginSupportService) -> nil,
--[[
Saves the engine data in replicated storage as attribute with the name "UpsideEngineDB" can be useful to create plugins
	]]
SavePluginContent: (self: PluginSupportService, content: {}) -> nil,
}




--[[
This class save and build the engine data
	]]
export type SceneManager = EventEmitter & {
--[[
]]
Scenes: 	{ 	},
--[[
This dictionary stores all the active scenes
	]]
ActiveScenes: 	{ 	},
--[[
]]
new: () -> SceneManager,
--[[
Finds a scene by the name
	]]
FindByName: (self: SceneManager, name: string) -> Scene?,
--[[
Returns the scene with the specified Id
	]]
Get: (self: SceneManager, Id: string) -> Scene,
}




export type upsideEngine = {
	Version: string,
	Workspace: {},
	new: ((name: "PhysicalObject") -> PhysicalObject)
		& ((name: "Sprite") -> Sprite)
		& ((name: "Sound") -> Sound)
		& ((name: "Environment") -> Environment)
		& ((name: "Light") -> Light)
		& ((name: "Character") -> Character)
		& ((name: "Scene") -> Scene)
		& ((name: "Particle") -> Particle),

	GetService: ((name: "SceneManager") -> SceneManager)
		& ((name: "PluginSupportService") -> PluginSupportService)
		& ((name: "NetworkingService") -> NetworkingService)
		& ((name: "CrossPlatformService") -> CrossPlatformService),
}

return {}
