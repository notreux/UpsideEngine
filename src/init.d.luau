-- THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
export type table = {}
export type Dictionary<k, v> = {}
export type Array<v> = {}
export type ChromaticAberrationConnection = {}

export type Event = {
	Functions: table,
	Threads: table,
}

export type RequestContent = {
	ClassName: string,
	Id: string,
	Name: string,
	ObjectProperties: table,
	Instance: table,
}

export type Raycast2dResult = {
	Object: PhysicalObject,
	Position: UDim2,
	Distance: Vector2,
	Normal: UDim2,
}

export type Raycast2dParams = {
	FilterType: string,
	From: Vector2,
	List: Array<BaseObject>,
	To: Vector2,
}

export type BaseClass = {
	Id: string,
	ClassName: string,
	Name: string,
	new: () -> BaseClass,
	SetName: (self: BaseClass, name: string) -> (),
	IsA: (self: BaseClass, className: string) -> boolean,
	Clone: (self: BaseClass, ...any) -> BaseClass,
	Destroy: (self: BaseClass) -> (),
}
--[[
This class is the base class of the majority of classes
	]]
export type BaseObject = EventEmitter & {
--[[
The object instance
  ]]
Instance: Instance,
--[[
The object scene ID
  ]]
Scene: string,
--[[
This table stores all the tags of the object
]]
Tags: { },
--[[
Sets the object scene
	]]
SetScene: (self: BaseObject, scene: Scene) -> nil,
--[[
Adds a tag to the object
	]]
AddTag: (self: BaseObject, tag: string) -> nil,
--[[
Checks if the object contain the specified tag
	]]
HasTag: (self: BaseObject, tag: string) -> boolean,
--[[
Removes a tag from the object
	]]
RemoveTag: (self: BaseObject, tag: string) -> nil,
}




--[[
This class is included on every scene, it's used to move you around the scene
	]]
export type Camera = EventEmitter & {
--[[
This property serves to move as many pixels as you want the camera to adjust it to a desired position
  ]]
OffsetPosition: UDim2,
--[[
This property is used to move the camera internally
  ]]
LocalPosition: Vector2,
--[[
This property marks the limits to move the camera, for example, if you set `Vector2.new(0.5, 0.5)` the camera will move only when it reaches the limit
  ]]
Limits: Vector2,
--[[
This property defines if the camera is going to follow the defined subject
  ]]
FollowSubject: boolean,
--[[
This is the Scene Id of the camera
  ]]
Scene: string,
--[[
This property defines the smoothness with which the camera will move, it only works in a range between 0 and 1
]]
Smoothness: number,
--[[
This property defines the object which is going to follow the camera
  ]]
Subject: Character,
--[[
Gets the camera position
	]]
GetPosition: (self: Camera) -> UDim2,
--[[
Sets the camera position
	]]
SetPosition: (self: Camera, udim2: UDim2) -> nil,
--[[
Sets the camera subject
	]]
SetSubject: (self: Camera, subject: Character) -> nil,
--[[
Position the camera in a centered location relative to the provided object
	]]
LookTo: (self: Camera, object: PhysicalObject) -> nil,
}




--[[
This class is used in the event emitter class, its used to manage a listener
	]]
export type Connection = BaseClass & {
--[[
Defines if the connection is active or not
  ]]
Active: boolean,
--[[
The id of the linked event
]]
EventId: number,
--[[
]]
Event: { },
--[[
Wait until the event gets fired, if seconds were specified, once the specified seconds have elapsed, it will stop waiting
	]]
Wait: (self: Connection, seconds: number?) -> thread?,
--[[
Deletes the connection and the listener
	]]
Disconnect: (self: Connection) -> nil,
}




--[[
The event emitter is used to manage the events of a class
	]]
export type EventEmitter = BaseClass & {
--[[
This table store all the events of the class
]]
EventsStorage: { },
--[[
]]
On: (self: EventEmitter, name: string, callback: () -> any) -> Connection,
--[[
Triggers an event with the specified arguments
	]]
Fire: (self: EventEmitter, name: string, ...any) -> nil,
}




--[[
This class is one of the most important components of a scene, is used to manage everything related with the light 
	]]
export type LightingEnvironment = Environment & {
--[[
This is the color of every pixel of the ambient, we can say is the darkness color
  ]]
AmbientColor: Color3,
--[[
This is the transparency of the ambient, we can say is the darkness transparency
  ]]
AmbientTransparency: number,
--[[
This is the seconds between every update of the pixels in the screen
  ]]
UpdateFrequency: number,
--[[
This is the intensity for all the lights in the scene
  ]]
LightIntensity: number,
--[[
Determines the light rendering mode, there are two modes Enum.ResamplerMode.Pixelated and Enum.ResamplerMode.Default
  ]]
LightStyle: Enum,
--[[
Determines the resolution for every chunk of the screen
]]
ChunkResolution: Vector2,
--[[
Draws the pixels for the scene with the specified resolution
	]]
DrawPixels: (self: LightingEnvironment) -> nil,
--[[
Updates the position, the transparency and the color of the ambient
	]]
UpdateScreen: (self: LightingEnvironment) -> nil,
}




--[[
]]
export type ObjectEnvironment = Environment & {
}




--[[
]]
export type ParticleEnvironment = Environment & {
}




--[[
This class is used for the client replication
	]]
export type Request = EventEmitter & {
--[[
The content of the request
  ]]
Content: { },
--[[
The UserId of the client which sent the request if exists 
	]]
ClientId: string,
--[[
Sends the request to the server
	]]
Send: (self: Request, content: Dictionary<string, any>) -> nil,
--[[
The request is approved and its replicated all the clients
	]]
Approve: (self: Request) -> nil,
--[[
Accepts the request and builds the object to be replicated
	]]
Accept: (self: Request) -> BaseObject,
--[[
Returns the player which sent the request
	]]
GetClient: (self: Request) -> Player,
}




--[[
]]
export type ShaderEnvironment = Environment & {
}




--[[
]]
export type SoundEnvironment = Environment & {
}




--[[
This class is used for the player character and for npcs
	]]
export type Character = Sprite & {
--[[
The amount of health of the character
  ]]
Health: number,
--[[
The maximum amount of health of the character 
  ]]
MaxHealth: number,
--[[
The walk speed of the character
  ]]
WalkSpeed: number,
--[[
The jump power of the character
  ]]
JumpPower: number,
--[[
Set to true when the character is jumping
]]
IsJumping: boolean,
--[[
Updates the amount of health of the character 
	]]
UpdateHealth: (self: Character, Health: number) -> nil,
--[[
The character jumps with the provided jump power, if none is provided it will use the JumpPower property as value 
	]]
Jump: (self: Character, jumpPower: number?) -> nil,
--[[
The character walks directly to the provided position
	]]
MoveTo: (self: Character, target: Vector2) -> nil,
}




--[[
This class is used to storage objects and interact with them in an easier way
	]]
export type Environment = BaseObject & {
--[[
]]
Content: { },
--[[
The amount of objects in this environment
]]
Count: number,
--[[
Gets the object with the specified index
	]]
Get: (self: Environment, index: string) -> any,
--[[
Adds an object with the specified index, if no parameter is specified it will use the next number of the count property as index
	]]
SetOne: (self: Environment, value: any, index: string) -> nil,
--[[
Adds an object with the specified index, if no parameter is specified it will use the next number of the count property as index
	]]
AddOne: (self: Environment, value: any, index: string) -> nil,
--[[
Removes the object with the specified index
	]]
RemoveOne: (self: Environment, index: string) -> nil,
--[[
Checks if the environment has a value with the specified index
	]]
HasOne: (self: Environment, index: string) -> boolean,
--[[
Checks if the environment contains every specified index and returns a boolean and a dictionary with boolean values, example:
	```lua
	local hasAll, dictionary = treeEnv:Has({
		"Tree1",
		"Tree2",
		"Tree4"
	})

	print(hasAll, dictionary) -- output: false, { Tree1 = true, Tree2 = true, Tree4 = false }
	```
	]]
Has: (self: Environment, objects: Array<string>) -> (boolean, Dictionary<string, boolean>),
--[[
Adds objects with the specified index
	```lua
	treeEnv:Add({
		"Tree1" = tree.new(),
		"Tree2" = tree.new(),
		"Tree3" = tree.new()
	})

	print(treeEnv:Get("Tree2")) -- output: Tree2
	```
	]]
Add: (self: Environment, objects: Dictionary<string, any>) -> nil,
--[[
Removes the objects with the specified index, example:
	```lua
	treeEnv:Remove({ "Tree1", "Tree2", "Tree3" })
	print(treeEnv:Get("Tree2")) -- output: nil
	```
	]]
Remove: (self: Environment, objects: Array<string>) -> nil,
--[[
Updates the objects with the specified index, example:
	```lua
	treeEnv:Update({
		Tree1 = treeEnv:Get("Tree2"),
		Tree2 = treeEnv:Get("Tree1"),
	})
	```
	]]
Update: (self: Environment, objects: Dictionary<string, any>) -> nil,
--[[
Finds an object by his name
	]]
FindByName: (self: Environment, name: string) -> any,
--[[
Sets the specified property in every object in the environment
	]]
SetProperty: (self: Environment, property: string, value: any) -> nil,
--[[
Executes the specified methods in every object in the environment with the specified parameters
	]]
Run: (self: Environment, method: string, ...any) -> nil,
}




--[[
This class is used to simulate fluids
	]]
export type Fluid = PhysicalObject & {
--[[
Indicates how much dense the fluid should be. Higher values indicate a denser fluid, 
        affecting buoyancy and movement of objects within the fluid
  ]]
Density: number,
--[[
Determines the flow resistance of the fluid. Higher values indicate a thicker fluid, 
        affecting the speed at which objects can move through it
  ]]
Viscosity: number,
--[[
Specifies the magnitude of the fluid waves. These waves are not visible but influence buoyancy and object stability.
  ]]
WavesAmplitude: number,
--[[
Determines how fast the waves should move
]]
WavesSpeed: number,
}




--[[
This class is used to illuminate areas in the darkness
	]]
export type Light = StaticObject & {
--[[
Is how the light should be shown, there are two modes "PointLight" and "SpotLight"
  ]]
Shape: string,
--[[
]]
Rotation: number,
--[[
]]
Angle: number,
--[[
The color you want the light to have
  ]]
Color: Color3,
--[[
Is the range of the light
  ]]
Range: number,
--[[
Is the brightness of the light
  ]]
Brightness: number,
--[[
!!!warning
  	Only works on Pointlights

  Inverts the light source
  ]]
Inverted: boolean,
}




--[[
This class is used to create inmersive backgrounds
	]]
export type Parallax = BaseObject & {
--[[
Defines the image zoom, if the value is 1X, 1Y it will see the whole image as expected, if you set it to 2X, 2Y you only will be able see half of the image
  ]]
CanvasSize: Vector2,
--[[
Defines the scroll position of the parallax object
  ]]
Offset: Vector2,
--[[
Defines if Update method should be called automatically
  ]]
Track: boolean,
--[[
Locks the Parallax object to the camera position
]]
LockToCamera: boolean,
--[[
Sets the tile texture
	]]
SetTexture: (self: Parallax, texture: string) -> nil,
--[[
Updates the parallax properties (position, canvasSize, etc.), its automatically called when Track is enabled
	]]
UpdateTiles: (self: Parallax) -> nil,
}




--[[
!!! warning 
  	Currently it's recommended to use sprites to make particles/vfx, this class is in experimental state and can change a lot

  _____
  This class is used for vfx

	]]
export type Particle = BaseObject & {
--[[
Depending on the value the particles will be more dispersed
  ]]
Angle: Vector2,
--[[
Is the tween info of the tween which is going to be used to move the particles
  ]]
Info: TweenInfo,
--[[
!!! warning 
  	Experimental, dont use
  ]]
TrackLight: boolean,
--[[
!!! warning 
  	Experimental, dont use
  ]]
CanCollide: boolean,
--[[
When its enabled new particles can be emitted
  ]]
Enabled: boolean,
--[[
Is the maximum amount of particles that can exist at the same time
  ]]
MaxRate: number,
--[[
Is the amount of particles that are existing at this moment
  ]]
Units: number,
--[[
!!! warning 
  	Experimental, dont use
  ]]
LightBrightness: number,
--[[
!!! warning 
  	Experimental, dont use
]]
LightRange: number,
--[[
Is the distance that can be traveled by each particle 
  ]]
Range: number,
--[[
The number of seconds the particle will be active before being destroyed
  ]]
LifeTime: number,
--[[
Used for internal purposes
  ]]
Clock: number,
--[[
Is the amount of particles which is going to be generated
  ]]
Rate: number,
--[[
The subject which is going to be the center of emission of the particle, a character, sprite, etc...
  ]]
Subject: Character,
--[[
Is a table with the initial properties of the particle which is going to be generated
  ]]
Properties: {
 --[[
@desc]]
Image: string,
},
--[[
Is a table with the goals of the particles
  ]]
Goals: {
 --[[
@desc]]
Size: UDim2,
--[[
@desc]]
ImageTransparency: number,
},
--[[
Sets the subject property
	]]
SetSubject: (self: Particle, subject: Character) -> nil,
--[[
Sets the angle property of the particle
	]]
SetAngle: (self: Particle, Angle: Vector2) -> nil,
--[[
Sets the maximum amount of particles that can exist at the same time
	]]
SetMaxRate: (self: Particle, maxRate: number) -> nil,
--[[
Emits the specified amount of particles, if none is provided then will use as amount the Rate property
	]]
Emit: (self: Particle, rate: number) -> nil,
}




--[[
This class is used to create objects with physics
	]]
export type PhysicalObject = StaticObject & {
--[[
Is the force which is applied in the moment to the object
  ]]
Force: Vector2,
--[[
Is the velocity applied to the object
  ]]
Velocity: Vector2,
--[[
Defines the rate of change of velocity for the physical object, initially set to zero.
	]]
Acceleration: Vector2,
--[[
This table stores all the active collisions
  ]]
Collisions: { },
--[[
This dictionary stores all the blacklisted objects, to blacklist an object do it like this:
  ```lua
  CollisionBlacklist[object.Id] = true
  ```
  ]]
CollisionBlacklist: { },
--[[
This the CollisionMask of the object
  ]]
Hitbox: { },
--[[
Specifies the geometric shape of the physical object, which can be "circle" and "custom" for polygons, custom is has box hitbox by default, also is the default shape.
  ]]
Shape: string,
--[[
The object mass
  ]]
Mass: number,
--[[
Change this property to change the hitbox size, the default value is 1
  ]]
HitboxScale: number,
--[[
A number which indicates the collision group of the object, the object only can collide with other objects with the same CollisionGroup
  ]]
CollisionGroup: number,
--[[
Determines the resistance to sliding motion between this object and another surface, influencing how quickly it slows down.
  ]]
Friction: number,
--[[
This property defines if the object should have physics or not
  ]]
Anchored: boolean,
--[[
This property defines if the object can collide with other objects
  ]]
CanCollide: boolean,
--[[
This property indicates if the object is touching the ground
  ]]
IsGrounded: boolean,
--[[
This property defines if the object is going to have physics and collisions or not
  ]]
TrackCollisions: boolean,
--[[
Applies force to the object
	]]
ApplyForce: (self: PhysicalObject, force: Vector2) -> nil,
}




--[[
This class is useful to have a workspace and manage your project more easily
	]]
export type Scene = BaseObject & {
--[[
The scene gravity
  ]]
Gravity: Vector2,
--[[
This property defines whether physics should be calculated only for visible objects
  ]]
OnlyTrackVisible: boolean,
--[[
The scene camera
  ]]
Camera: Camera,
--[[
This is the LightingEnvironment of the scene
  ]]
LightingEnvironment: LightingEnvironment,
--[[
This is the ParticleEnvironment of the scene
  ]]
ParticleEnvironment: ParticleEnvironment,
--[[
This is the SoundEnvironment of the scene
  ]]
SoundEnvironment: SoundEnvironment,
--[[
This is the ShaderEnvironment of the scene
]]
ShaderEnvironment: ShaderEnvironment,
--[[
This environment stores all the objects in the scene
  ]]
Objects: ObjectEnvironment,
--[[
Enables the scene, which will make it process physics, lights, sounds and sprites
	]]
Enable: (self: Scene) -> nil,
--[[
Disables the scene
	]]
Disable: (self: Scene) -> nil,
--[[
Gets all the objects with the provided tags in the scene
	]]
GetTaggedObjects: (self: Scene, tag: string) -> Array<string>,
--[[
Casts a ray using the Raycast2dParams. If it finds an elegible object a Raycast2dResult is returned containing the results of the operations
	]]
Raycast: (self: Scene, info: Raycast2dParams) -> Raycast2dResult,
}




--[[
!!! warning 
  	Shaders are very cpu-intensive, so it is not recommended to use them with high resolution images
  	and not to use too many shaders.

  	If you need to scale an image, do it in the studio, instead of doing it in the editing program, 
  	this will lighten a lot the work for the cpu.	

  _____
  This class is used to modify how an object is renderized
	]]
export type Shader = BaseClass & {
--[[
This property determines if the shader is enabled
  ]]
Enabled: boolean,
--[[
When this property is marked as true every animation of a sprite will be preloaded, 
  if not the animations will be loaded dynamically
  ]]
PreloadSprites: boolean,
--[[
This property determines if the shader will use the mirror source or not, false by default
        ]]
MirrorEnabled: boolean,
--[[
The current mirror source, nil by default ImageLabel if an object is set using SetMirrorSource()
  ]]
MirrorSource: ImageLabel,
--[[
Sometimes, modifying the position of pixels in an image can create gaps.
  Upside Engine automatically fills these gaps, but this can occasionally 
  lead to unwanted effects. Therefore, adjust this property according to your needs, 
  the value of this property ranges between 0 and 1.
]]
Precision: number,
--[[
This property stores the shader path
        ]]
Path: string,
--[[
Sets the mirror source object for rendering the shader. When a mirror source is specified, 
 the shader uses its `ImageRectOffset` and `ImageRectSize` to render. All objects to which this shader
 is applied will display the exact same result, mirroring the appearance of the source object. 
 If no mirror source is set, each object will be rendered independently, 
 which may lead to decreased performance.
	]]
SetMirrorSource: (self: Shader, object: StaticObject) -> nil,
--[[
Sets the module script which is going to be used as shader source
	]]
SetSource: (self: Shader, file: ModuleScript) -> nil,
}




--[[
This class is used to play sounds
	]]
export type Sound = BaseObject & {
--[[
This is the SoundEnvironment of the scene
  ]]
Range: number,
--[[
This is the ParticleEnvironment of the scene
  ]]
MaxVolume: number,
--[[
The volume will depend on the player distance
]]
DistanceFading: boolean,
--[[
This table stores all the objects in the scene
  ]]
Subject: Character,
--[[
Sets the provided character as subject, if is provided a sound group, this will be the new sound group of the sound
	]]
SetSubject: (self: Sound, subject: Character, useSceneSoundGroup: boolean?) -> nil,
}




--[[
This class is used to play sounds
	]]
export type Sprite = PhysicalObject & {
--[[
Indicates if the sprite is playing
  ]]
IsPlaying: boolean,
--[[
This is the time to wait between frame and frame
  ]]
SecondsPerFrame: number,
--[[
This table stores all sprite sheets and sprite lists 
  ]]
Sprites: { },
--[[
This table stores information about the active spritesheet
]]
Active: {
 --[[
@desc]]
Name: string,
--[[
@desc]]
CurrentFrame: Vector2,
--[[
@desc]]
SecondsPerFrame: number,
--[[
@desc]]
NextStepReady: boolean,
},
--[[
Adds a new sprite sheet to the object, the sprite will be played using as reference the amount of cells in the X axe and the Y axe, this must be provided in the third paramether as a Vector2
	]]
SetSpriteSheet: (self: Sprite, name: string, url: string, frames: Vector2) -> nil,
--[[
Adds a new sprite list to the object, it will play the animation using the order in the provided list, this list must contain the urls of every frame
	]]
SetSpriteList: (self: Sprite, name: string, list: Array<string>) -> nil,
--[[
Plays the specified sprite if exists, if secondsEveryFrame is specified it will be used instead of .SecondsPerFrame
	]]
Play: (self: Sprite, name: string, secondsPerFrame: number?) -> nil,
--[[
Stops the reproduction of the current playing sprite sheet or sprite list
	]]
Stop: (self: Sprite) -> nil,
}




--[[
This class is used to create a basic object, without physics or animations
	]]
export type StaticObject = BaseObject & {
--[[
This is the point which is being used as reference for the chromatic aberration
  ]]
ChromaticAberrationPoint: Vector2,
--[[
The instances which makes the chromatic aberration effect
  ]]
ChromaticAberration: { },
--[[
Is the shader of the object
]]
Shader: Shader,
--[[
]]
ChromaticAberrationIntensity: number,
--[[
]]
ChromaticAberrationDistance: number,
--[[
]]
ChromaticAberrationConnection: boolean,
--[[
Sets the shader for this object
	]]
SetShader: (self: StaticObject, shader: Shader) -> nil,
--[[
Loads an image for the current object and is set as the instance image
	]]
Load: (self: StaticObject, url: string) -> nil,
--[[
Sets chromatic aberration for the image using a center as reference, by default the center is the middle of the screen, 
 to disable the chromatic aberration send 0 as first parameter
 ]]
SetChromaticAberration: (self: StaticObject, Intensity: number, Distance: number, Point: Vector2) -> nil,
}




--[[
This class is used to make the controls functional in any device (Keyboards, Mobiles, Gamepads), this service vinculate actions 
 to specified keys, and also provides a movement system for the player character which can be disabled with the `DefaultControllersEnabled`
 property, here is an example to make our player jumps in every device:
```lua
--  								Device,	    Key, 	Action
CrossPlatformService:SetDeviceKey("Keyboard", "Space", "Up")
CrossPlatformService:SetDeviceKey("Mobile", "JumpButton", "Up")
CrossPlatformService:SetDeviceKey("Gamepad", "ButtonA", "Up")
```


But this is not limited only to movement actions, you can also assign other kind of actions, for example:


```lua
CrossPlatformService:SetDeviceKey("Keyboard", "E", "Collect")
CrossPlatformService:SetDeviceKey("Mobile", "JumpButton", "Collect")
CrossPlatformService:SetDeviceKey("Gamepad", "ButtonA", "Collect")
```


We assigned an action for our devices but how can we detect when an action is triggered? well we can listen to three events
"InputBegin", "InputChange", "InputEnd", example of use:


```lua
-- If the movement belongs to a stick, the second parameter will give the current position of the stick
CrossPlatformService:On("InputBegin", function(inputObject)
	local character = CrossPlatformService.Character

	if inputObject.Action == "Up" then
		character:Jump(150)
	end
end)
```

	]]
export type CrossPlatformService = EventEmitter & {
--[[
Defines if the default movement system is enabled
  ]]
DefaultControllersEnabled: boolean,
--[[
Defines if the character is going to be seen from the side or from the top
  ]]
SideView: boolean,
--[[
This is the sensibility of the sticks in mobile and in game controllers
  ]]
StickSensibility: number,
--[[
This is the character which is going to be tracked by the camera
  ]]
Character: Character,
--[[
This table stores the default controllers
	]]
Configs: {
 --[[
@desc]]
Keyboard: {
 	--[[
@desc]]
W: string,
	--[[
@desc]]
A: string,
	--[[
@desc]]
S: string,
	--[[
@desc]]
D: string,
	--[[
@desc]]
Up: string,
	--[[
@desc]]
Left: string,
	--[[
@desc]]
Down: string,
	--[[
@desc]]
Right: string,
	--[[
@desc]]
Space: string,
	},
--[[
@desc]]
Gamepad: {
 	--[[
@desc]]
ButtonA: string,
	--[[
@desc]]
Thumbstick1: {
 		--[[
@desc]]
Up: string,
		--[[
@desc]]
Left: string,
		--[[
@desc]]
Down: string,
		--[[
@desc]]
Right: string,
		},
	},
--[[
@desc]]
Mobile: {
 	--[[
@desc]]
JumpButton: string,
	--[[
@desc]]
Thumbstick1: {
 		--[[
@desc]]
Up: string,
		--[[
@desc]]
Left: string,
		--[[
@desc]]
Down: string,
		--[[
@desc]]
Right: string,
		},
	},
},
--[[
Assigns an action to a device key, example:
	```lua
	CrossPlatformService:SetDeviceKey("Keyboard", "Space", "Up")
	```
	]]
SetDeviceKey: (self: CrossPlatformService, device: string, key: string, action: string) -> nil,
--[[
Sets the entire configuration of a device, example:
	```lua
	CrossPlatformService:SetDeviceConfig("Keyboard", {
		W = "Up",
		A = "Left",
		S = "Down",
		D = "Right",

		Up = "Up",
		Left = "Left",
		Down = "Down",
		Right = "Right",
		Space = "Up",
	})
	```
	]]
SetDeviceConfig: (self: CrossPlatformService, device: string, controls: Dictionary<string, string>) -> nil,
--[[
Sets the player character
	]]
SetPlayerCharacter: (self: CrossPlatformService, character: Character) -> nil,
}




--[[
This class is used to replicate objects to other clients, for example the player character
	]]
export type NetworkingService = EventEmitter & {
--[[
Defines if the replicated objects by other clients should be destroyed when they leaves
	]]
DestroyObjectsOnLeave: boolean,
--[[
]]
ReplicationTarget: { },
--[[
]]
PlayersData: { },
--[[
Replicates an object to other clients
]]
Replicate: (self: NetworkingService, object: BaseObject) -> nil,
--[[
Replicates an object and each change on it, and returns the connections that detect each change of the object
	]]
ReplicateOnChange: (self: NetworkingService, object: BaseObject) -> RBXScriptConnection,
}




--[[
This class save and build the engine data
]]
export type PluginSupportService = EventEmitter & {
--[[
Loads the engine data stored in the "UpsideEngineDB" attribute of replicated storage, when it ends sets the attribute as an empty table
	]]
LoadPluginContent: (self: PluginSupportService) -> nil,
--[[
Saves the engine data in replicated storage as attribute with the name "UpsideEngineDB" can be useful to create plugins
	]]
SavePluginContent: (self: PluginSupportService, content: {}) -> nil,
}




--[[
This class save and build the engine data
	]]
export type SceneManager = EventEmitter & {
--[[
]]
Scenes: { },
--[[
This dictionary stores all the active scenes
	]]
ActiveScenes: { },
--[[
Finds a scene by the name
	]]
FindByName: (self: SceneManager, name: string) -> Scene?,
--[[
Returns the scene with the specified Id
	]]
Get: (self: SceneManager, Id: string) -> Scene,
}




export type upsideEngine = {
	Version: string,
	Workspace: {},
	new: ((name: "PhysicalObject") -> PhysicalObject)
		& ((name: "StaticObject") -> StaticObject)
		& ((name: "Fluid") -> Fluid)
		& ((name: "Parallax") -> Parallax)
		& ((name: "Sprite") -> Sprite)
		& ((name: "Sound") -> Sound)
		& ((name: "Environment") -> Environment)
		& ((name: "Light") -> Light)
		& ((name: "Character") -> Character)
		& ((name: "Scene") -> Scene)
		& ((name: "Particle") -> Particle)
		& ((name: "Shader") -> Shader),

	GetService: ((name: "SceneManager") -> SceneManager)
		& ((name: "PluginSupportService") -> PluginSupportService)
		& ((name: "NetworkingService") -> NetworkingService)
		& ((name: "CrossPlatformService") -> CrossPlatformService),
}

return {}
